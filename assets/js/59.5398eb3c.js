(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{534:function(v,_,t){"use strict";t.r(_);var a=t(30),l=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"正则的匹配原理与优化原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#正则的匹配原理与优化原则"}},[v._v("#")]),v._v(" 正则的匹配原理与优化原则")]),v._v(" "),t("h2",{attrs:{id:"有穷状态自动机"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有穷状态自动机"}},[v._v("#")]),v._v(" 有穷状态自动机")]),v._v(" "),t("ul",[t("li",[v._v("有穷状态：一个具有有穷个状态的系统")]),v._v(" "),t("li",[v._v("自动机：可以根据相应的条件，自动在不同状态下进行转移。")]),v._v(" "),t("li",[v._v("有穷自动机的具体实现称为正则引擎，主要有DFA和NFA两种，NFA又包括了传统的NFA和POSIX NFA")])]),v._v(" "),t("h2",{attrs:{id:"dfa匹配过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dfa匹配过程"}},[v._v("#")]),v._v(" DFA匹配过程")]),v._v(" "),t("ul",[t("li",[v._v("以文本为主，先看文本，再看正则")]),v._v(" "),t("li",[v._v("整个过程字符串只看一遍，不回溯")]),v._v(" "),t("li",[v._v("没有引用功能，也不支持捕获子组")]),v._v(" "),t("li",[v._v("代表有MySQL，Golang")])]),v._v(" "),t("h2",{attrs:{id:"nfa匹配过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nfa匹配过程"}},[v._v("#")]),v._v(" NFA匹配过程")]),v._v(" "),t("ul",[t("li",[v._v("以正则为主，先看正则，再看文本")]),v._v(" "),t("li",[v._v("会发生回溯，同一字符可能会测多次")]),v._v(" "),t("li",[v._v("支持子组，和反向引用")]),v._v(" "),t("li",[v._v("代表有Java，Python")]),v._v(" "),t("li",[v._v("POSIX NFA会尝试所有可能的匹配，返回最长最左的匹配")])]),v._v(" "),t("h2",{attrs:{id:"优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优化"}},[v._v("#")]),v._v(" 优化")]),v._v(" "),t("ol",[t("li",[v._v("使用ipython来测试正则性能")]),v._v(" "),t("li",[v._v("提前编译好正则")]),v._v(" "),t("li",[v._v("尽量准确表示匹配范围")]),v._v(" "),t("li",[v._v("提取公共部分")]),v._v(" "),t("li",[v._v("出现可能性大的放左边")]),v._v(" "),t("li",[v._v("警惕嵌套子组重复")]),v._v(" "),t("li",[v._v("避免不同分支重复匹配")])])])}),[],!1,null,null,null);_.default=l.exports}}]);